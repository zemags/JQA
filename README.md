# Жизненный цикл ПО #

### -каскадная модель - в больших конторах - корпорации ###
	этапы:
		1. системный анализ - на уровне бизнеса (обсуждение с заказчиком)
		2. анализ требований - на уровне бизнеса (обсуждение с заказчиком)
		3. проектирование - разработка - архитектор на основании требований
		4. кодирование - программисты
		5. тестирование - можно сразу писать как получили требования, или после кодирования
			- роль тестироващика написать тесты по требованиям
		6. внедрение и сопровождение
	минусы:
		- получение продукта только после прохождения всех этапов
		- заказчик может поменять желание и т.д.
		- на первом месте не стоит обратная связь от клиента

### -agile - каждый жизненный цикл ПО выдавать user story (когда уже ПО работает хотя бы минимально ) ###
	этапы:
		1. plan - планирование, smart цель, action plan
		2. do - внедрение, измерение результатов, контроль, решение проблем
		3. check study - мониторинг, анализ, коррекция, аудит
		4. act - выявление системной ошибки, оптимизация, новая стратегия задача
	плюсы:
		- все время обратная связь с клиентом

### scrum - спринты, роли, команда, продакт, скрам мастер (scrum как правило не соблюдается) ###
### kanban - приоритизация задач (задачи постоянно идут) ###
### итеративная модель - улучшение продукта(пример: итерация одна неделя, улучшение или разработка новых фичей) ###


# Требования к ПО #
- b2b
	- обычно документации больше (более подробно), формализованный процесс по договоренности сторон
- b2c
	- меньше формализованного процесса

## формальные требования (типы) ##
	- требования отсутствуют
	- задачи в jira
	- требования в свободной форме в wiki обычно в confluence
	- подробной документации
## неформальные требования ##
	- продукт не крашется
	- не теряются данные (например при работе с БД)
	- с продуктом можно работать (например удобна ли фича в ПО)

# Тест дизайн #
## сертификация тестировщика ##
	- istqb - для работы в штатах (уровни базовый, продвинутый, эксперт)
## методики тест дизайна ##
	- черный ящик - не знаем как работает софт
	- белый ящик - есть исходный код, если есть необходимость смотреть в код
	- серый ящик - продукт на сервере, знанием ресурсы (сеть процессор память)
## функциональное тестирование ##
	- метод граничных значений - 80% задача на этой методике (пример фильтр цены покупок в онлайн магазине)
	- метод класса эквивалентности (по принимает данные и выдает результат, пример по принимает на вход даты числа строки фио, каждое значение это класс эквивалентности)
## нефункциональное тестирование ##
	- тестирование юзабилити, безопасности, производительности (если например определять геоположение трактора в поле, тут нужна производительность больше и т.д.)

*Second Part*
## Характеристики качества ##
- функциональность
- портативность
- удобство сопровождения
- эффективность
- юзабилити
- надежность

## QA, QC, software testing ##
QA - на ранних этапах ПО, понимает какие шаблоны удачные, какие потенциальные проблемы, не допускает появления ошибок (процессо - ориентированной подход)
QC - анализирует требования, нужды пользователей, составляет чеклисты (продукт)
software testing - проходит чек листы и тест кейсы, работает с продуктом, дизайном, покрывает кейсами ПО (прохождение кейсов)

## Цели тестирования ##
1. предоставить инфу о реальном состоянии ПО
2. показать что ПО соответствует требованиям
3. нахождение дефектов, в первую очередь критические ошибки за минимальное время

## Принципы тестирования ##
1. показать наличие дефекта ПО, но доказать невозможно\сложно (неправильно подобранный кейс)
2. избыточное тестирование недостижимо (все комбинации недостижимы)
3. ранний процесс тестирования - сохранить деньги\дешевле
4. дефект кластеринг - "в 20% местах ПО 80% багов"
5. принцип пестицида - необходимо при изменении требовании\документаций менять тест кейсы
6. тестирование контексто-зависимо - тестить ракеты и тестить по магазина
7. заблуждение отсутствия ошибок - "нет гарантий что все ок, если так кажется"

## Фундаментальный процесс разработки ##
*цель тестирования - не допустить репутационные\финансовые ошибки*
### Шесть этапов ###
1. планирование - основано на определенном наборе результатов (осуществим ли проект)
2. анализ - технико-экономические\нагрузка\сбор требований и т.д.
3. дизайн\проектирование - рекомендации команде\продумка каждой детали, как будет выглядеть готовое ПО
4. разработка - требования\дизайн в программный код
5. тестирование и внедрение
6. поддержка

## Фундаментальный процесс тестирования ##
1. анализ требований - прямые и косвенные, рекомендации
2. установка окружения - создание инфраструктуры, что необходимо и какие данные нужны
3. планирование теста - оценка времени по тестированию (пункты 1, 2 и другое планирование)
4. разработка теста - разработка тест кейсы, чек листы
5. запуск тестов - на основе планов испытаний запуск тестов, ошибка передается в разработку обратно *bag report*
6. закрытие - завершение тестирования (ретроспектива на тест)

## Техники контроля качества ##
верификация - правильно ли делаем, оценка системы с целью проверить удовлетворяет ли требований (юнит тесты, авто тесты..)
валидация - правильную ли мы работу делаем, удовлетворяет ли ПО ожиданием пользователя (приемочные тесты, тесты юзабилити)

## Три вида ошибок ##
1. defect - непреднамеренное отклонения фактического результата от ожидаемого результата
2. failure - система сама по себе сбоит, это не баг, это исключение
3. error - ошибка пользователя, использования ПО не по назначению